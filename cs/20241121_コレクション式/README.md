ここでのコードは .NET8 で書いています。

# コレクション式
## とにかく `[ ]` で初期化できる
コレクション式とは C#12 からの機能で、どのようなコレクションでもとにかく `[ ]` で初期化できるようになるものです。
``` cs
int[] array = [1, 2, 3];
List<int> list = [1, 2, 3];
Span<int> span = [1, 2, 3];
ReadOnlySpan<int> ros = [1, 2, 3];
ImmutableArray<int> immutable = [1, 2, 3];
```

## コレクション初期化子との違い
これまではデータ型に応じて書き方を変える必要がありました。例えば `List<int>` の初期化は次のようなコレクション初期化子を用いた書き方をしていたと思います。
``` cs
var list = new List<int>() { 1, 2, 3, 4, 5 };
```
これをコンパイルすると次のようなコードに展開されます。
``` cs
List<int> list2 = new List<int>();
list2.Add(1);
list2.Add(2);
list2.Add(3);
list2.Add(4);
list2.Add(5);
List<int> list = list2;
```
コレクション初期化子とは、コーディングする人がいちいち `Add` メソッドを呼び出してコードを書く手間を省くために導入された機能で、いわゆる糖衣構文（シンタックスシュガー）と呼ばれるものです。

これに対してコレクション式を用いた初期化は次のように書けます。
``` cs
List<int> list = [1, 2, 3, 4, 5];
```
これはただの糖衣構文ではなく、明らかにパフォーマンスを意識したコードに展開されます。
``` cs
int num = 5;
List<int> list2 = new List<int>(num);
CollectionsMarshal.SetCount(list2, num);
Span<int> span = CollectionsMarshal.AsSpan(list2);
int num2 = 0;
span[num2] = 1;
num2++;
span[num2] = 2;
num2++;
span[num2] = 3;
num2++;
span[num2] = 4;
num2++;
span[num2] = 5;
num2++;
List<int> list = list2;
```
プログラムが長くなって何がパフォーマンスが良くなったのか分からないかもしれませんが、`Add` メソッドの中身を知ると良く分かります。

`List<T>` クラスは内部に配列を持っていて、コレクション要素はこの配列が実態となります。したがってこの配列を拡張しながら `Add` や `Remove` をおこなっています。`Add` メソッドはだいたい次のような手順で動作します。
1. 内部の配列に格納された要素数を確認する
2. コレクションとして登録した要素数と配列の要素数が一致した場合、`Add` メソッドで渡された値を格納する場所がないので、現在の内部配列の倍の長さの配列を改めてオブジェクト化する
3. 新しい配列に古い配列の要素をすべてコピーして、古い配列は捨てる
4. 新しい配列の現在の末尾に `Add` メソッドで渡された値を格納する

引数なしのコンストラクタで `new` した場合、内部の配列の長さは 0 です。この後、`Add` メソッドを呼び出すたびに配列の長さが 4、8、16、... と倍々に増えていきます。このため、`Add` メソッドを呼び出すたびに内部で配列の生成と要素のコピーがおこなわれるため、`Add` メソッドの呼び出し回数が多いほど処理は重く、GC の対象となるオブジェクトも増えることになります。対処法としては、初期化時点で `new List<T>(10)` などのように配列の長さを指定しておくことです。これにより、オブジェクト化するときに配列の長さをあらかじめ指定できるため、その長さまでの回数であれば `Add` メソッドを呼んでも配列のコピー処理は発生しなくなります。

これに対してコレクション式によって展開されたコードでは、配列の長さを指定して `new List<T>(num)` が呼び出され、その後、配列の各要素に直接値を格納するようにしています。

このサンプル程度の長さだとパフォーマンスに違いは現れませんが、それでも他のコレクションと統一して同じ書き方で初期化できるというメリットがあります。その上、この書き方をしていればコンパイラが勝手に良い感じのコードにしてくれるのであれば、コレクション式を使わない手はありません。

## `foreach` での `null` チェックに応用
`foreach` でよくあるのが、イテレーション対象の `null` チェックです。
``` cs
private void Print(IEnumerable<int>? list)
{
  if (list is not null)
  {
    foreach (var item in list)
    {
      Console.WriteLine(item);
    }
  }
}
```
foreach したいだけなのにいちいち `null` チェックが煩わしいし、書き方にもよりますがムダにネストが一つ深くなります。これに対してコレクション式を使うとスッキリ書くことができます。
``` cs
private void PrintList(IEnumerable<int>? list)
{
  foreach (var item in list ?? [])  // list が null のときにイテレーション対象が Array.Empty<int>() になるのでイテレーションしない
  {
    Console.WriteLine(item);
  }
}
```
`[]` と書くと空のコレクションを生成することになります。`foreach` は `null` に対しては例外が発生しますが、空のコレクションに対しては何も起こりません。そのため、`list` が `null` の場合は例外が発生することなく、さらにイテレーションがおこなわれないことになります。

## スプレッド演算子 `..`
既存のコレクションを使って新たなコレクションを初期化できる演算子です。
``` cs
List<int> list1 = [1, 2, 3];
List<int> list2 = [4, 5, 6];
int[] array1 = [.. list1, .. list2];
```
このコードは LINQ の `Concat` メソッドを使った次のコードと結果は同じになります。
``` cs
int[] array1 = list1.Concat(list2).ToArray();
```
しかし、コレクション式は一番パフォーマンスが良いと思われるコードに展開されるように作られているため、積極的に取り入れたい書き方です。
